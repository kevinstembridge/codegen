// This source was generated by the Mahana Mongogen generator
// Renderer class: class com.mahanaroad.mongogen.generator.entities.DaoRenderer
// Rendered at: 2016-09-30T22:30:59.772Z

package com.mahanaroad.mongogen.sample.user;

import com.mahanaroad.mongogen.persist.AbstractEntityDao;
import com.mahanaroad.mongogen.persist.MongoClientFacade;
import com.mahanaroad.mongogen.sample.types.FirstName;
import com.mahanaroad.mongogen.sample.types.LastName;
import com.mahanaroad.mongogen.types.CollectionName;
import java.time.Instant;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;


@Repository
public class UserDao extends AbstractEntityDao<UserEntity> {

    private final UserEntityFieldConverter fieldConverter = new UserEntityFieldConverter() {

        @Override
        public Object convert(final String collectionFieldName, final Object inputValue) {

            switch(collectionFieldName) {

                case "c-ts":
                    return Date.from((Instant) inputValue);
                case "ep":
                    return inputValue;
                case "fn":
                    return ((FirstName) inputValue).getValue();
                case "_id":
                    return inputValue;
                case "lm-ts":
                    return Date.from((Instant) inputValue);
                case "ln":
                    return ((LastName) inputValue).getValue();
                 default:
                     throw new RuntimeException("Unknown collectionFieldName [" + collectionFieldName + "]");
            }

        }

    };


    private final MongoClientFacade mongoClientFacade;


    @Autowired
    public UserDao(final MongoClientFacade mongoClientFacade) {

        super(new CollectionName("party"), mongoClientFacade);

        Objects.requireNonNull(mongoClientFacade, "mongoClientFacade");

        this.mongoClientFacade = mongoClientFacade;

    }


    @Override
    protected Document toDocumentFrom(final UserEntity entity) {

        final Document document = new Document();

        document.put("TYP", "USR");
        document.put("c-ts", Date.from(entity.getCreatedTimestampUtc()));
        document.put("ep", entity.getEncryptedPassword());
        document.put("fn", entity.getFirstName().getValue());
        document.put("_id", entity.getId());
        entity.getLastModifiedTimestampUtc().ifPresent(lastModifiedTimestampUtc -> document.put("lm-ts", Date.from(lastModifiedTimestampUtc)));
        document.put("ln", entity.getLastName().getValue());

        return document;

    }


    @Override
    protected Document toUpsertDocumentFrom(final UserEntity entity) {

        final Document modifiableFieldsDocument = new Document();
        final Document unmodifiableFieldsDocument = new Document();

        unmodifiableFieldsDocument.put("TYP", "USR");
        modifiableFieldsDocument.put("ep", entity.getEncryptedPassword());
        modifiableFieldsDocument.put("fn", entity.getFirstName().getValue());
        modifiableFieldsDocument.put("ln", entity.getLastName().getValue());
        unmodifiableFieldsDocument.put("c-ts", Date.from(entity.getCreatedTimestampUtc()));
        unmodifiableFieldsDocument.put("_id", entity.getId());
        entity.getLastModifiedTimestampUtc().ifPresent(lastModifiedTimestampUtc -> unmodifiableFieldsDocument.put("lm-ts", Date.from(lastModifiedTimestampUtc)));

        return new Document()
                .append("$setOnInsert", unmodifiableFieldsDocument)
                .append("$set", modifiableFieldsDocument);

    }


    @Override
    protected UserEntity toEntityFrom(final Document document) {

        final Instant createdTimestampUtc = readInstant("c-ts", "createdTimestampUtc", document);
        final String encryptedPassword = readString("ep", "encryptedPassword", document);
        final FirstName firstName = readString(FirstName::new, "fn", "firstName", document);
        final ObjectId id = readObjectId("_id", "id", document);
        final Optional<Instant> lastModifiedTimestampUtc = readInstantOptional("lm-ts", document);
        final LastName lastName = readString(LastName::new, "ln", "lastName", document);

        return new UserEntity(
                createdTimestampUtc,
                encryptedPassword,
                firstName,
                id,
                lastModifiedTimestampUtc,
                lastName);

    }


    public long count(final UserEntityFilter filter) {

        final Bson bsonFilter = filter.toBson(this.fieldConverter);
        return super.count(bsonFilter);

    }


    public List<UserEntity> findAllBy(final UserEntityFilter filter) {

        final Bson bsonFilter = filter.toBson(this.fieldConverter);
        return super.find(bsonFilter);

    }


    public Page<UserEntity> findAll(final Pageable pageable) {

        return super.find(pageable);

    }


    public Page<UserEntity> findAllBy(final UserEntityFilter filter, final Pageable pageable) {

        final Bson bsonFilter = filter.toBson(this.fieldConverter);
        return super.find(bsonFilter, pageable);

    }


    public void setFields(final UserEntityUpdater updater) {

        final Bson bson = updater.toBson(this.fieldConverter);
        super.updateOneById(updater.getId(), bson);

    }


    protected final String convertClassFieldNameToCollectionFieldName(final String classFieldName) {

        switch(classFieldName) {
            case "createdTimestampUtc":
                return "c-ts";
            case "encryptedPassword":
                return "ep";
            case "firstName":
                return "fn";
            case "id":
                return "_id";
            case "lastModifiedTimestampUtc":
                return "lm-ts";
            case "lastName":
                return "ln";
            default:
                throw new IllegalArgumentException("Unknown classFieldName [" + classFieldName + "]");
        }

    }


    protected final Optional<String> getTypeDiscriminator() {

        return Optional.of("USR");

    }


}
